# -*- coding: utf-8 -*-
"""Main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xHCQijGxOiNYK1_YPH_5QLh02WuevXza
"""

import numpy as np
import pandas as pd
import tensorflow as tf
import keras
import sys
import os
import glob
import shutil
from tensorflow.keras.models import Sequential,load_model
from tensorflow.keras.layers import Dense, Flatten, Conv2D, Dropout, BatchNormalization, GlobalAveragePooling2D
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import ModelCheckpoint
import matplotlib.pyplot as plt
import cv2
import tensorflow
from google.colab.patches import cv2_imshow
from PIL import Image
from tensorflow.keras import models
from tensorflow.keras import layers
from tensorflow.keras import optimizers
from IPython.display import Image
!pip install utils
from utils import *

def extract(img) : 
  kernel = np.ones((5,5))
  img2=img.copy()
  gray_img=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
  
  gray_img = cv2.adaptiveThreshold(gray_img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
	                                     cv2.THRESH_BINARY_INV, blockSize = 321, C = 80)
  gray_img = cv2.GaussianBlur(gray_img, (3, 3), 0)
  gray_img = cv2.dilate(gray_img,kernel,iterations = 3)
  gray_img = cv2.erode(gray_img,kernel,iterations = 1)
  
  gray_image = cv2.morphologyEx(gray_img, cv2.MORPH_CLOSE, kernel)
  # gray_img=cv2.copyMakeBorder(gray_img,20,20,20,20,cv2.BORDER_CONSTANT)
  # cv2_imshow(gray_img)

  lst=[]
  for j in range(gray_image.shape[1]):
    sum = 0
    for i in range(gray_image.shape[0]):
      sum = sum+gray_image[i][j]
    lst.append(sum)
  # print(lst)
  rect = []
  f = 0
 
  for i in range(len(lst)):
    if lst[i] != 0 and f==0:
      x1=i
      f=1
    elif lst[i] == 0 and f==1:
      x2=i
      if(abs(x1-x2)>30):
        rect.append([min(x1,x2),max(x1,x2)])
      f=0 

  for k in range(len(rect)):
    x1=rect[k][0]
    x2=rect[k][1]
    lst2=[]
    for i in range(gray_image.shape[0]):
      sum=0
      for j in range(min(x1,x2),max(x1,x2)+1):
        sum = sum+gray_image[i][j]
      lst2.append(sum)
    # print(lst2)

    f=0
    for i in range(len(lst2)):
      if lst2[i] != 0 and f==0:
        y1=i
        f=1
      if lst2[i] == 0 and f==1:
        y2=i
        if(abs(y2-y1)>30):
          rect[k].append(min(y1,y2))
          rect[k].append(max(y1,y2))
        f=0 
  # print(rect)

  for i in range(len(rect)):
    if(len(rect[i])==4) :
      cv2.rectangle(img2,(rect[i][0],rect[i][2]),(rect[i][1],rect[i][3]),(0,255,0),3)
  cv2_imshow(img2)
  
  return gray_img, rect

def predict(image):
    num_classes=26
    model_emoji = load_model('/content/drive/MyDrive/mosaic/model_emoji.h5')
    model = load_model('/content/drive/MyDrive/mosaic/model_full.h5')
    class_mapping='1234567ABDEFHJKLMNPRSTWXYZ'
    count=0
    total=0
    images, rect=extract(image)
    answer=""
    for i in range(len(rect)):
        # kernel = np.ones((3,3))
        if(len(rect[i])==4):
          image1=images[rect[i][2]:rect[i][3], rect[i][0]:rect[i][1]]
        else:
          continue
        image1=cv2.copyMakeBorder(image1,40,40,40,40,cv2.BORDER_CONSTANT)
        # image1 = cv2.morphologyEx(image1, cv2.MORPH_CLOSE, kernel)
        image1 = cv2.resize(image1, (28, 28))
        cv2_imshow(image1)
        image1 = (np.array(image1)).reshape(1 , 28 , 28 , 1)
        image1=image1/255

        result = np.argmax(model.predict(image1))
        result_confidence=np.max(model.predict(image1))

        result1 = np.argmax(model_emoji.predict(image1))
        result_confidence1=np.max(model_emoji.predict(image1))
        # print("model",class_mapping[result],result_confidence)
        if(result_confidence1-result_confidence>0.10 and result_confidence<0.75):
          print("model_emoji",class_mapping[result1],result_confidence1)
          answer+=(class_mapping[result1])
        else :
          print("model",class_mapping[result],result_confidence)
          answer+=(class_mapping[result])
    return answer

img_path = '/content/img2.jpeg'
img = cv2.imread(img_path)
captcha = predict(img)
print("Captcha is",captcha)



